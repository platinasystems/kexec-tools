Description: [PowerPC64] Fix failure in purgatory when compiled with gcc5
 Application of upstream fixes so kexec-tools work with gcc5 on PowerPC64

 commit	4a2ae3a39c64dc43e9d094be9541253234ff4822
 Pass struct mem_sym into machine_apply_elf_rel()
 On PowerPC64 ABIv2 we need to look at the symbol to determine
 if it has a local entry point. Pass struct mem_sym into
 machine_apply_elf_rel() so we can.

 commit	1e423dc297d10eb7ff25c829d2856ef12fc81d77
 ppc64: purgatory: Handle local symbols in ELF ABIv2
 The PowerPC64 ELF ABIv2 has the concept of global and local symbols
 and information on this is encoded in sym->st_other. When doing a
 R_PPC64_REL24 branch we want to hit the local entry point, so adjust
 it as necessary.

 commit	3debb8cf3272216119cb2e59a4963ce3c18fe8e3
 Properly align powerpc64 .toc
 gcc leaves .toc byte aligned, relying on the linker to align the section.
 	* kexec/arch/ppc64/kexec-elf-rel-ppc64.c (machine_verify_elf_rel):
	  Fudge alignment of .toc section.

Author: Anton Blanchard <anton@samba.org>, Alan Modra <amodra@gmail.com>
Origin: <upstream>
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/kexec-tools/+bug/1546260
--- a/kexec/arch/arm/kexec-elf-rel-arm.c
+++ b/kexec/arch/arm/kexec-elf-rel-arm.c
@@ -18,8 +18,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *location,
+	unsigned long address, unsigned long value)
 {
 	switch(r_type) {
 	case R_ARM_ABS32:
--- a/kexec/arch/cris/kexec-elf-rel-cris.c
+++ b/kexec/arch/cris/kexec-elf-rel-cris.c
@@ -29,8 +29,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *location,
+	unsigned long address, unsigned long value)
 {
 	switch(r_type) {
 
--- a/kexec/arch/i386/kexec-elf-rel-x86.c
+++ b/kexec/arch/i386/kexec-elf-rel-x86.c
@@ -18,8 +18,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *location,
+	unsigned long address, unsigned long value)
 {
 	switch(r_type) {
 	case R_386_32:
--- a/kexec/arch/ia64/kexec-elf-rel-ia64.c
+++ b/kexec/arch/ia64/kexec-elf-rel-ia64.c
@@ -72,8 +72,9 @@
         return insn & ~0xfUL;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *location,
+	unsigned long address, unsigned long value)
 {
 	uint64_t gp_value = ehdr->rel_addr + 0x200000;
 	switch(r_type) {
--- a/kexec/arch/m68k/kexec-elf-rel-m68k.c
+++ b/kexec/arch/m68k/kexec-elf-rel-m68k.c
@@ -23,7 +23,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+			   struct mem_sym *UNUSED(sym),
+			   unsigned long r_type,
 			   void *UNUSED(location),
 			   unsigned long UNUSED(address),
 			   unsigned long UNUSED(value))
--- a/kexec/arch/mips/kexec-elf-rel-mips.c
+++ b/kexec/arch/mips/kexec-elf-rel-mips.c
@@ -29,7 +29,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+			   struct mem_sym *UNUSED(sym),
+			   unsigned long r_type,
 			   void *UNUSED(location),
 			   unsigned long UNUSED(address),
 			   unsigned long UNUSED(value))
--- a/kexec/arch/ppc64/kexec-elf-rel-ppc64.c
+++ b/kexec/arch/ppc64/kexec-elf-rel-ppc64.c
@@ -5,17 +5,23 @@
 #include "../../kexec-elf.h"
 #include "kexec-ppc64.h"
 
-int machine_verify_elf_rel(struct mem_ehdr *ehdr)
-{
-	if (ehdr->ei_class != ELFCLASS64) {
-		return 0;
-	}
-	if (ehdr->e_machine != EM_PPC64) {
-		return 0;
-	}
+#if defined(_CALL_ELF) && _CALL_ELF == 2
+#define STO_PPC64_LOCAL_BIT	5
+#define STO_PPC64_LOCAL_MASK	(7 << STO_PPC64_LOCAL_BIT)
+#define PPC64_LOCAL_ENTRY_OFFSET(other) \
+ (((1 << (((other) & STO_PPC64_LOCAL_MASK) >> STO_PPC64_LOCAL_BIT)) >> 2) << 2)
 
-	return 1;
+static unsigned int local_entry_offset(struct mem_sym *sym)
+{
+	/* If this symbol has a local entry point, use it. */
+	return PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);
 }
+#else
+static unsigned int local_entry_offset(struct mem_sym *UNUSED(sym))
+{
+	return 0;
+}
+#endif
 
 static struct mem_shdr *toc_section(const struct mem_ehdr *ehdr)
 {
@@ -34,6 +40,24 @@
 	return NULL;
 }
 
+int machine_verify_elf_rel(struct mem_ehdr *ehdr)
+{
+	struct mem_shdr *toc;
+
+	if (ehdr->ei_class != ELFCLASS64) {
+		return 0;
+	}
+	if (ehdr->e_machine != EM_PPC64) {
+		return 0;
+	}
+
+	/* Ensure .toc is sufficiently aligned.  */
+	toc = toc_section(ehdr);
+	if (toc && toc->sh_addralign < 256)
+		toc->sh_addralign = 256;
+	return 1;
+}
+
 /* r2 is the TOC pointer: it actually points 0x8000 into the TOC (this
    gives the value maximum span in an instruction which uses a signed
    offset) */
@@ -63,8 +87,9 @@
 	*location = (*location & ~mask) | (value & mask);
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *ehdr, struct mem_sym *sym,
+	unsigned long r_type, void *location, unsigned long address,
+	unsigned long value)
 {
 	switch(r_type) {
 	case R_PPC64_ADDR32:
@@ -113,6 +138,7 @@
 		break;
 
 	case R_PPC64_REL24:
+		value += local_entry_offset(sym);
 		/* Convert value to relative */
 		value -= address;
 		if (value + 0x2000000 > 0x3ffffff || (value & 3) != 0) {
--- a/kexec/arch/ppc/kexec-elf-rel-ppc.c
+++ b/kexec/arch/ppc/kexec-elf-rel-ppc.c
@@ -17,8 +17,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *location,
+	unsigned long address, unsigned long value)
 {
 	switch(r_type) {
 	case R_PPC_ADDR32:
--- a/kexec/arch/s390/kexec-elf-rel-s390.c
+++ b/kexec/arch/s390/kexec-elf-rel-s390.c
@@ -23,7 +23,8 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *ehdr,
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+			   struct mem_sym *UNUSED(sym),
 			   unsigned long r_type,
 			   void *loc,
 			   unsigned long address,
--- a/kexec/arch/sh/kexec-elf-rel-sh.c
+++ b/kexec/arch/sh/kexec-elf-rel-sh.c
@@ -28,8 +28,9 @@
 	return 1;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
-	void *orig_loc, unsigned long UNUSED(address), unsigned long relocation)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *orig_loc,
+	unsigned long UNUSED(address), unsigned long relocation)
 {
 	uint32_t *location = orig_loc;
 	uint32_t value;
--- a/kexec/arch/x86_64/kexec-elf-rel-x86_64.c
+++ b/kexec/arch/x86_64/kexec-elf-rel-x86_64.c
@@ -57,8 +57,9 @@
 	return name;
 }
 
-void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr), unsigned long r_type,
-	void *location, unsigned long address, unsigned long value)
+void machine_apply_elf_rel(struct mem_ehdr *UNUSED(ehdr),
+	struct mem_sym *UNUSED(sym), unsigned long r_type, void *location,
+	unsigned long address, unsigned long value)
 {
 	dbgprintf("%s\n", reloc_name(r_type));
 	switch(r_type) {
--- a/kexec/kexec-elf.h
+++ b/kexec/kexec-elf.h
@@ -129,7 +129,8 @@
 
 /* Architecture specific helper functions */
 extern int machine_verify_elf_rel(struct mem_ehdr *ehdr);
-extern void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type, 
-	void *location, unsigned long address, unsigned long value);
+extern void machine_apply_elf_rel(struct mem_ehdr *ehdr, struct mem_sym *sym,
+	unsigned long r_type, void *location, unsigned long address,
+	unsigned long value);
 #endif /* KEXEC_ELF_H */
 
--- a/kexec/kexec-elf-rel.c
+++ b/kexec/kexec-elf-rel.c
@@ -408,7 +408,7 @@
 			dbgprintf("sym: %s value: %lx addr: %lx\n",
 				name, value, address);
 
-			machine_apply_elf_rel(ehdr, rel.r_type,
+			machine_apply_elf_rel(ehdr, &sym, rel.r_type,
 				(void *)location, address, value);
 		}
 	}
